<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billiards and Beyond</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Black Ops One', cursive;
            color: white;
            user-select: none;
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-size: 24px;
            text-shadow: 0 0 10px cyan;
            width: 100%;
        }
       
        .hud-left-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .token-display {
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
        }

        #speed-display {
            color: #00ffcc;
            font-size: 20px;
            text-shadow: 0 0 5px #00ffcc;
        }

        #best-run-display {
            color: #ff00ff;
            font-size: 20px;
            text-shadow: 0 0 5px #ff00ff;
        }

        .bottom-ui {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .ability-bar-container {
            width: 300px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .sub-ability-row {
            display: flex;
            gap: 20px;
        }

        .small-ability {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .small-ability .key {
            font-size: 10px;
            color: #ccc;
            margin-bottom: 2px;
            text-transform: uppercase;
        }

        .small-bar {
            width: 80px;
            height: 10px;
            border: 1px solid #fff;
            border-radius: 5px;
            background: rgba(0,0,0,0.5);
            overflow: hidden;
        }

        .fill-bar {
            height: 100%;
            width: 100%;
            transform-origin: left;
            transition: width 0.1s;
        }

        #ability-fill { background: linear-gradient(90deg, #ff00cc, #3333ff); }
        #scratch-fill { background: #00ff00; }
        #spin-fill { background: #ffaa00; }
        #bank-fill { background: #00ccff; }
        #chalk-fill { background: #ff55ff; }
        #magic8-fill { background: #000000; border-right: 2px solid white; }
        #nineball-fill { background: #ffee00; }

        #ability-text {
            position: absolute;
            top: -25px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 5px #ff00cc;
        }

        #upgrade-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
            overflow: hidden;
        }

        .card-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
            perspective: 1000px;
        }

        /* --- CARD STYLING --- */
        .card {
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 2px solid #444;
            padding: 15px;
            width: 180px;
            height: 240px;
            border-radius: 15px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            position: relative;
            transform: translateY(-800px) rotateX(20deg);
            opacity: 0;
            transition: 
                transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), 
                opacity 0.4s ease, 
                border-color 0.2s, 
                box-shadow 0.2s;
            overflow: hidden;
        }

        .card.drop-in {
            transform: translateY(0) rotateX(0deg);
            opacity: 1;
        }

        .card.slide-out {
            transform: translateX(1200px) rotate(20deg);
            opacity: 0;
            pointer-events: none;
        }
       
        .card.selected {
            border-color: #ffd700;
            box-shadow: 0 0 20px #ffd700;
            background: linear-gradient(135deg, #2a2600, #3d3700);
        }

        /* --- RARE CARDS --- */
        .card.rare {
            background: linear-gradient(135deg, #12002e, #310061);
            border: 2px solid #8b00ff;
            animation: rarePulse 3s infinite ease-in-out;
        }
       
        .card.rare h3 {
            color: #d1b3ff;
            text-shadow: 0 0 10px #8b00ff;
        }

        @keyframes rarePulse {
            0%, 100% { box-shadow: 0 0 15px rgba(139, 0, 255, 0.4); border-color: #8b00ff; }
            50% { box-shadow: 0 0 30px rgba(139, 0, 255, 0.7); border-color: #d1b3ff; }
        }

        /* --- GOLDEN CARDS --- */
        .card.golden {
            background: linear-gradient(135deg, #b8860b, #ffd700, #daa520);
            border: 3px solid #fff;
            box-shadow: 0 0 35px #ffd700;
        }

        .card.golden::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: repeating-linear-gradient(
                -45deg,
                rgba(255, 255, 255, 0.1) 0,
                rgba(255, 255, 255, 0.1) 2px,
                transparent 0,
                transparent 10px
            );
            pointer-events: none;
            z-index: 1;
        }

        .card.golden::after {
            content: "";
            position: absolute;
            top: 0;
            left: -150%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.4),
                transparent
            );
            transform: skewX(-20deg);
            animation: lightSweep 2.5s infinite;
            z-index: 2;
        }

        @keyframes lightSweep {
            0% { left: -150%; }
            30% { left: 150%; }
            100% { left: 150%; }
        }

        .card.golden h3 {
            color: #fff;
            text-shadow: 0 2px 4px #4e3800;
            z-index: 3;
            position: relative;
        }

        .card.golden p {
            color: #111;
            font-weight: bold;
            z-index: 3;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: #00ffcc;
            box-shadow: 0 0 20px #00ffcc;
        }

        .card h3 {
            color: #00ffcc;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .card p {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(50, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 20;
        }

        #tutorial-dialogue {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffcc;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            display: none;
            z-index: 30;
            cursor: pointer;
        }
       
        #tutorial-text-content {
            font-size: 20px;
            color: white;
            margin-bottom: 10px;
        }

        #click-prompt {
            font-size: 14px;
            color: #aaa;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        button {
            background: #ff0055;
            border: none;
            padding: 15px 40px;
            font-family: 'Black Ops One', cursive;
            font-size: 24px;
            color: white;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 5px;
            box-shadow: 0 0 15px #ff0055;
            transition: transform 0.2s;
        }

        button:hover {
            background: #ff3377;
            transform: scale(1.1);
        }

        #reroll-btn {
            background: #daa520;
            box-shadow: 0 0 20px #ffd700;
            font-size: 18px;
            padding: 10px 25px;
            display: none;
        }

        .tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 1;
            transition: opacity 1s;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-left-group">
                <div id="health-display">HP: 100</div>
                <div id="speed-display" style="display:none;">0 IN/S</div>
            </div>
            <div class="hud-right-group" style="text-align: right;">
                <div id="token-display" class="token-display">TOKENS: 0</div>
                <div id="level-display">MENU</div>
                <div id="best-run-display" style="display:none;">BEST: 0</div>
            </div>
        </div>
        <div class="tutorial" id="tutorial-text" style="display:none;">
            <h1>WASD to Roll</h1>
            <h2>SPACE to Summon Cue Stick</h2>
        </div>
       
        <div class="bottom-ui" id="game-ui" style="display:none;">
            <div class="ability-bar-container">
                <div id="ability-text">CUE STRIKE READY (SPACE)</div>
                <div id="ability-fill" class="fill-bar"></div>
            </div>

            <div class="sub-ability-row">
                <div class="small-ability" id="scratch-ui" style="display:none; opacity: 0.5;">
                    <span class="key">SCRATCH [E]</span>
                    <div class="small-bar"><div id="scratch-fill" class="fill-bar"></div></div>
                </div>
                <div class="small-ability" id="spin-ui" style="display:none; opacity: 0.5;">
                    <span class="key">SPIN [Q]</span>
                    <div class="small-bar"><div id="spin-fill" class="fill-bar"></div></div>
                </div>
                <div class="small-ability" id="bank-ui" style="display:none; opacity: 0.5;">
                    <span class="key">BANK [R]</span>
                    <div class="small-bar"><div id="bank-fill" class="fill-bar"></div></div>
                </div>
                <div class="small-ability" id="chalk-ui" style="display:none; opacity: 0.5;">
                    <span class="key">CHALK [F]</span>
                    <div class="small-bar"><div id="chalk-fill" class="fill-bar"></div></div>
                </div>
                <div class="small-ability" id="nineball-ui" style="display:none; opacity: 0.5;">
                    <span class="key">9 BALL [H]</span>
                    <div class="small-bar"><div id="nineball-fill" class="fill-bar"></div></div>
                </div>
                <div class="small-ability" id="magic8-ui" style="display:none; opacity: 0.5;">
                    <span class="key">MAGIC 8 BALL [G]</span>
                    <div class="small-bar"><div id="magic8-fill" class="fill-bar"></div></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Upgrade Overlay -->
    <div id="upgrade-overlay">
        <h1 id="upgrade-title" style="font-size: 40px; color: #fff; text-shadow: 0 0 20px #00ffcc; margin: 0; text-align: center;">LEVEL CLEARED</h1>
        <h2 id="upgrade-subtitle" style="color: #aaa; margin: 5px; text-align: center;">CHOOSE AN UPGRADE</h2>
        <div class="card-container" id="cards-wrapper"></div>
        <button id="reroll-btn" onclick="triggerReroll()">REROLL (1 LEFT)</button>
    </div>

    <!-- Tutorial Dialogue -->
    <div id="tutorial-dialogue">
        <div id="tutorial-text-content">Text goes here</div>
        <div id="click-prompt">[ CLICK TO CONTINUE ]</div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen">
        <h1 style="font-size: 64px; color: #ff0055; text-shadow: 0 0 30px red;">SCRATCHED</h1>
        <h2 id="final-level">Level Reached: 1</h2>
        <h3 id="earned-tokens" style="color: gold; margin-top: 0;">Tokens Earned: 0</h3>
        <button onclick="returnToMenu()">RETURN TO MENU</button>
    </div>

<script>

// --- CONFIGURATION ---
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
const BORDER_SIZE = 50;
const PHYSICS_STEPS = 8;

// --- CARD DATABASE ---
const CARD_POOL = [
    { id: 'split', name: "Split", rarity: 'golden', price: 60, desc: "Grow 10% per kill. At 150% size, reset and launch 2 exploding mini-balls.", type: 'unique', action: (p) => { p.hasSplitAbility = true; } },
    { id: 'retry', name: "Retry", rarity: 'golden', price: 50, desc: "Unlock a Reroll button for upgrades. Useable once per level.", type: 'unique', action: (p) => { p.hasRerollAbility = true; } },
    { id: 'skill', name: "Skill", rarity: 'common', price: 10, desc: "Permanent +10% Damage and +10% Speed. No limit.", type: 'stat', stat: 'damage', val: 0.1, sideEffect: (p) => { p.statMultipliers.speed += 0.1; } },
    { id: 'snack_break', name: "Snack Break", rarity: 'common', price: 10, desc: "Heal +10 HP if you don't hit or get hit for 2s. Increases per stack (Max x10).", type: 'unique', action: (p) => { p.snackStacks = Math.min(10, p.snackStacks + 1); } },
    { id: 'streak', name: "Streak", rarity: 'common', price: 10, desc: "1.5x Damage for 0.3s after a kill. Duration increases with stacks (Max x5).", type: 'unique', action: (p) => { p.streakStacks = Math.min(5, p.streakStacks + 1); } },
    { id: 'heavy', name: "Heavy Core", rarity: 'common', price: 10, desc: "Massively increase Damage + Size, but reduce Speed.", type: 'stat', stat: 'damage', val: 0.5, sideEffect: (p) => { p.statMultipliers.size *= 1.2; p.statMultipliers.speed *= 0.8; } },
    { id: 'chalk', name: "Quick Draw", rarity: 'common', price: 8, desc: "Cooldown for Cue Strike reduced.", type: 'stat', stat: 'cooldown', val: 0.25 },
    { id: 'glass', name: "Glass Cannon", rarity: 'common', price: 12, desc: "Double Damage, half Max HP.", type: 'stat', stat: 'damage', val: 1.0, sideEffect: (p) => { p.maxHp /= 2; p.hp = Math.min(p.hp, p.maxHp); } },
    { id: 'aero', name: "Aerodynamics", rarity: 'common', price: 8, desc: "Move 30% Faster.", type: 'stat', stat: 'speed', val: 0.3 },
    { id: 'aero_minus', name: "Aerodynamics -", rarity: 'common', price: 6, desc: "Move 20% Faster.", type: 'stat', stat: 'speed', val: 0.2 },
    { id: 'bullet', name: "Bullet", rarity: 'common', price: 10, desc: "+10% Damage, +10% Speed, but -5% Size.", type: 'stat', stat: 'damage', val: 0.1, sideEffect: (p) => { p.statMultipliers.speed += 0.1; p.statMultipliers.size *= 0.95; } },
    { id: 'shell', name: "Reinforced Shell", rarity: 'common', price: 10, desc: "Take 30% less damage.", type: 'stat', stat: 'defense', val: 0.3 },
    { id: 'ghost', name: "Ghost Ball", rarity: 'common', price: 12, desc: "15% Chance to dodge damage.", type: 'stat', stat: 'dodge', val: 0.15 },
    { id: 'sniper', name: "Sniper", rarity: 'common', price: 10, desc: "Cue Strike travels 2x faster.", type: 'stat', stat: 'projSpeed', val: 1.0 },
    { id: 'thorns', name: "Spiked", rarity: 'common', price: 10, desc: "Deal 5 damage to enemies on contact.", type: 'stat', stat: 'thorns', val: 5 },
    { id: 'felt', name: "Expensive Felt", rarity: 'common', price: 8, desc: "Stops movement faster when letting go (Better Control).", type: 'unique', action: (p) => { p.friction *= 0.98; } },
    { id: 'clean', name: "Clean Hit", rarity: 'common', price: 12, desc: "+4% Speed for 2s after hitting an enemy (Stacks x5).", type: 'unique', action: (p) => { p.hasCleanHit = true; } },
    { id: 'nitro', name: "Nitro Rail", rarity: 'common', price: 14, desc: "Bouncing off walls gives a short speed burst.", type: 'unique', action: (p) => { p.hasNitroRail = true; } },
    { id: 'diamond', name: "Diamond Dust", rarity: 'common', price: 15, desc: "Permanent +2 Damage and +5% Speed.", type: 'stat', stat: 'damage', val: 0.2, sideEffect: (p) => { p.statMultipliers.speed += 0.05; } },
   
    // RARE CARDS
    { id: 'lifesteal', name: "Lifesteal", rarity: 'rare', price: 25, desc: "Heal +3 extra HP per kill. (Caps at 20 HP total).", type: 'unique', action: (p) => { p.healPerKill = Math.min(20, p.healPerKill + 3); } },
    { id: 'defend', name: "Defend", rarity: 'rare', price: 28, desc: "Gain immunity frames after getting hit. (Caps at 0.8s).", type: 'unique', action: (p) => { p.iFrameDuration = Math.min(0.8, p.iFrameDuration + 0.2); } },
    { id: 'aero_plus', name: "Aerodynamics +", rarity: 'rare', price: 30, desc: "Gives a massive +50% Speed boost.", type: 'stat', stat: 'speed', val: 0.5 },
    { id: 'midas', name: "Midas", rarity: 'rare', price: 35, desc: "Glow yellow every few seconds. Getting hit freezes the attacker. (Caps x4).", type: 'unique', action: (p) => { p.midasStacks = Math.min(4, p.midasStacks + 1); p.updateMidas(); } },
    { id: 'regen', name: "Regeneration", rarity: 'rare', price: 32, desc: "Heal 1 HP over time. (Caps x5).", type: 'unique', action: (p) => { p.regenStacks = Math.min(5, p.regenStacks + 1); p.updateRegen(); } }
];

// --- STATE MANAGEMENT ---
let gameState = 'MENU';
let game = {
    active: false,
    level: 1,
    paused: false,
    width: window.innerWidth,
    height: window.innerHeight,
    camera: { x: 0, y: 0, shake: 0 },
    slowMo: 1.0,
    hitStop: 0,
    impactFrame: 0,
    upgradePending: false,
    scale: 1.0,
    rerollSpentThisLevel: false
};

let gameSettings = {
    particles: true,
    trails: true,
    impactFrames: true
};

let tutorial = {
    step: 0,
    clickPending: false,
    timer: 0
};

let cutscene = {
    active: false,
    timer: 0,
    type: 'NONE',
    text: '',
    outcome: null,
    phase: 0
};

let globalTokens = 0;
let globalBestRun = 0;

function loadData() {
    try {
        let t = localStorage.getItem('neonPoolRogue_tokens');
        if (t) globalTokens = parseFloat(t);
       
        let b = localStorage.getItem('neonPoolRogue_best');
        if (b) globalBestRun = parseInt(b);
    } catch (e) {
        console.warn("Storage not available");
    }
}
function saveData() {
    try {
        localStorage.setItem('neonPoolRogue_tokens', globalTokens);
        localStorage.setItem('neonPoolRogue_best', globalBestRun);
    } catch (e) {
        console.warn("Storage not available");
    }
}

let runBuffs = {
    stats: { speed: 0, health: 0, damage: 0 },
    cards: []
};

let shopPrices = {
    speed: 1.0,
    health: 1.0,
    damage: 1.0
};

// FIX: Reset function for Shop and Run specific data
function resetRunState() {
    runBuffs = {
        stats: { speed: 0, health: 0, damage: 0 },
        cards: []
    };
    shopPrices = {
        speed: 1.0,
        health: 1.0,
        damage: 1.0
    };
}

// --- INPUTS ---
const keys = { w: false, a: false, s: false, d: false, space: false, e: false, q: false, r: false, f: false, g: false, h: false, one: false, u: false, i: false };

window.addEventListener('keydown', e => {
    if(e.key === 'w' || e.key === 'ArrowUp') keys.w = true;
    if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = true;
    if(e.key === 's' || e.key === 'ArrowDown') keys.s = true;
    if(e.key === 'd' || e.key === 'ArrowRight') keys.d = true;
    if(e.key === '1') keys.one = true;
    if(e.key === 'u' || e.key === 'U') keys.u = true;
    if(e.key === 'i' || e.key === 'I') keys.i = true;
   
    if(e.key === ' ') {
        if (!keys.space && player && !game.paused) player.activateAbility();
        keys.space = true;
    }
    if(e.key === 'e' || e.key === 'E') {
        if (!keys.e && player) player.activateScratch();
        keys.e = true;
    }
    if(e.key === 'q' || e.key === 'Q') {
        if (!keys.q && player) player.activateSpin();
        keys.q = true;
    }
    if(e.key === 'r' || e.key === 'R') {
        if (!keys.r && player) player.activateBank();
        keys.r = true;
    }
    if(e.key === 'f' || e.key === 'F') {
        if (!keys.f && player) player.activateChalk();
        keys.f = true;
    }
    if(e.key === 'g' || e.key === 'G') {
        if (!keys.g && player) player.activateMagic8();
        keys.g = true;
    }
    if(e.key === 'h' || e.key === 'H') {
        if (!keys.h && player) player.activateNineBall();
        keys.h = true;
    }

    if (keys.one && keys.w && keys.u && keys.i && player && (gameState === 'PLAYING' || gameState === 'MENU')) {
        player.unlockAllAbilities();
    }
});
window.addEventListener('keyup', e => {
    if(e.key === 'w' || e.key === 'ArrowUp') keys.w = false;
    if(e.key === 'a' || e.key === 'ArrowLeft') keys.a = false;
    if(e.key === 's' || e.key === 'ArrowDown') keys.s = false;
    if(e.key === 'd' || e.key === 'ArrowRight') keys.d = false;
    if(e.key === '1') keys.one = false;
    if(e.key === 'u' || e.key === 'U') keys.u = false;
    if(e.key === 'i' || e.key === 'I') keys.i = false;
   
    if(e.key === ' ') keys.space = false;
    if(e.key === 'e' || e.key === 'E') keys.e = false;
    if(e.key === 'q' || e.key === 'Q') keys.q = false;
    if(e.key === 'r' || e.key === 'R') keys.r = false;
    if(e.key === 'f' || e.key === 'F') keys.f = false;
    if(e.key === 'g' || e.key === 'G') keys.g = false;
    if(e.key === 'h' || e.key === 'H') keys.h = false;
});

window.addEventListener('mousedown', () => {
    if (gameState === 'TUTORIAL' && tutorial.clickPending) {
        advanceTutorial();
    }
});

// --- UTILS ---
const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
const rand = (min, max) => Math.random() * (max - min) + min;
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

function getGlobalScale() {
    if (gameState === 'CHAOS_MODE') return 0.5;
    if (gameState !== 'PLAYING' && gameState !== 'TUTORIAL' && gameState !== 'CUTSCENE_MAGIC8' && gameState !== 'MAGIC8_ATTACK') return 1.0;
    if (game.level >= 20) return 0.5;
    if (game.level >= 10) return 0.6;
    if (game.level >= 5) return 0.75;
    return 1.0;
}

function applyCard(card, player) {
    runBuffs.cards.push(card.id);
    let count = runBuffs.cards.filter(id => id === card.id).length;
    let multiplier = Math.pow(0.66, count - 1);
    let effectiveVal = (card.val || 0) * (card.id === 'skill' ? 1.0 : multiplier);

    if (card.type === 'stat') {
        if (card.stat === 'damage') player.statMultipliers.damage += effectiveVal;
        if (card.stat === 'speed') player.statMultipliers.speed += effectiveVal;
        if (card.stat === 'defense') player.statMultipliers.defense += effectiveVal;
        if (card.stat === 'dodge') player.dodgeChance += effectiveVal;
        if (card.stat === 'cooldown') player.abilityMaxCooldown *= (1 - effectiveVal);
        if (card.stat === 'projSpeed') player.projectileSpeedMult += effectiveVal;
        if (card.stat === 'thorns') player.thorns += effectiveVal;
       
        if (card.sideEffect) card.sideEffect(player);
    }
    else if (card.type === 'unique') {
        if (card.action) card.action(player);
    }
}

// --- CLASSES ---

class Particle {
    constructor(x, y, color, speed, size, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = Math.random() * speed;
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.life = life;
        this.maxLife = life;
        this.size = size * game.scale;
        this.decay = Math.random() * 0.05 + 0.02;
    }

    update() {
        this.x += this.vx * game.slowMo;
        this.y += this.vy * game.slowMo;
        this.vx *= 0.95;
        this.vy *= 0.95;
        this.life -= this.decay * game.slowMo;
    }

    draw(ctx) {
        if (!gameSettings.particles) return;
        ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class FloatingText {
    constructor(x, y, text, color, size) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.size = size * game.scale;
        this.life = 1.0;
        this.vy = -2 * game.scale;
    }

    update() {
        this.y += this.vy * game.slowMo;
        this.life -= 0.02 * game.slowMo;
    }

    draw(ctx) {
        if (this.life <= 0) return;
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.font = `bold ${this.size}px 'Black Ops One'`;
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

class ToggleZone {
    constructor(x, y, settingKey, label) {
        this.x = x;
        this.y = y;
        this.radius = 50;
        this.settingKey = settingKey;
        this.label = label;
        this.timer = 0;
        this.maxTimer = 60;
    }
   
    update() {
        let d = dist(player.x, player.y, this.x, this.y);
        if (d < this.radius) {
            this.timer++;
            if (this.timer >= this.maxTimer) {
                gameSettings[this.settingKey] = !gameSettings[this.settingKey];
                this.timer = 0;
                game.camera.shake = 5;
                createParticles(this.x, this.y, gameSettings[this.settingKey] ? '#00ff00' : '#ff0000', 15, 5);
            }
        } else {
            this.timer = 0;
        }
    }

    draw(ctx) {
        let isOn = gameSettings[this.settingKey];
        ctx.strokeStyle = isOn ? '#00ff00' : '#ff0000';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);

        if (this.timer > 0) {
            ctx.fillStyle = isOn ? 'rgba(255, 0, 0, 0.3)' : 'rgba(0, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.arc(this.x, this.y, this.radius, -Math.PI/2, -Math.PI/2 + (Math.PI*2 * (this.timer/this.maxTimer)));
            ctx.fill();
        }

        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.font = '16px Black Ops One';
        ctx.fillText(this.label, this.x, this.y - 10);
        ctx.fillStyle = isOn ? '#00ff00' : '#ff0000';
        ctx.fillText(isOn ? "ON" : "OFF", this.x, this.y + 15);
    }
}

function pickWeightedCard() {
    let r = Math.random();
    let rarityPicked = 'common';
    // UPDATED ODDS: Golden (0.5%), Rare (5%), Common (94.5%)
    if (r < 0.005) rarityPicked = 'golden';
    else if (r < 0.055) rarityPicked = 'rare'; 
    else rarityPicked = 'common';

    let pool = CARD_POOL.filter(c => {
        if (c.rarity !== rarityPicked) return false;
        if (c.id === 'split' && player.hasSplitAbility) return false;
        if (c.id === 'streak' && player.streakStacks >= 5) return false;
        if (c.id === 'snack_break' && player.snackStacks >= 10) return false;
        if (c.id === 'retry' && player.hasRerollAbility) return false;
        if (c.rarity === 'rare') {
            if (c.id === 'lifesteal' && player.healPerKill >= 20) return false;
            if (c.id === 'defend' && player.iFrameDuration >= 0.8) return false;
            if (c.id === 'midas' && player.midasStacks >= 4) return false;
            if (c.id === 'regen' && player.regenStacks >= 5) return false;
        }
        return true;
    });

    if (pool.length === 0) return CARD_POOL.find(c => c.id === 'skill');
    return pool[Math.floor(Math.random() * pool.length)];
}

class ShopZone {
    constructor(x, y, type, data, index) {
        this.x = x;
        this.y = y;
        this.radius = 60;
        this.type = type;
        this.data = data;
        this.index = index;
        this.timer = 0;
        this.maxTimer = 180;
       
        if (this.type === 'STAT') {
            this.price = shopPrices[this.data.stat];
        } else {
            this.price = this.data.card.price;
        }
    }

    update() {
        let d = dist(player.x, player.y, this.x, this.y);
        if (d < this.radius) {
            if (globalTokens >= this.price) {
                this.timer++;
                if (this.timer >= this.maxTimer) {
                    this.buy();
                }
            } else {
                this.timer = 0;
            }
        } else {
            this.timer = 0;
        }
    }

    buy() {
        globalTokens = Math.round((globalTokens - this.price) * 10) / 10;
        saveData();
        createParticles(this.x, this.y, '#ffd700', 30, 10);
        game.camera.shake = 10;
       
        if (this.type === 'STAT') {
            runBuffs.stats[this.data.stat]++;
            shopPrices[this.data.stat] = Math.round((shopPrices[this.data.stat] * 1.5) * 10) / 10;
            this.price = shopPrices[this.data.stat];
        } else {
            applyCard(this.data.card, player);
            let newCard = pickWeightedCard();
            shopItems[this.index] = new ShopZone(this.x, this.y, 'CARD', {card: newCard}, this.index);
        }
       
        this.timer = 0;
        texts.push(new FloatingText(this.x, this.y - 50, "PURCHASED!", '#00ff00', 30));
    }

    draw(ctx) {
        ctx.strokeStyle = '#fff';
        if (this.type === 'CARD' && this.data.card.rarity === 'rare') {
            ctx.setLineDash([]);
            ctx.lineWidth = 4;
            let hue = (Date.now() / 10) % 360;
            ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
        } else if (this.type === 'CARD' && this.data.card.rarity === 'golden') {
            ctx.lineWidth = 5;
            ctx.strokeStyle = '#ffd700';
            ctx.setLineDash([]);
        } else {
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
        }
       
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.stroke();
        ctx.setLineDash([]);

        if (this.timer > 0) {
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.arc(this.x, this.y, this.radius, -Math.PI/2, -Math.PI/2 + (Math.PI*2 * (this.timer/this.maxTimer)));
            ctx.fill();
        }

        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        ctx.font = '16px Black Ops One';
       
        let label = "";
        if (this.type === 'STAT') {
            if (this.data.stat === 'health') label = "+10 MAX HP";
            else label = "+10% " + this.data.stat.toUpperCase();
        }
        else label = this.data.card.name;

        ctx.fillText(label, this.x, this.y - 10);
       
        ctx.fillStyle = globalTokens >= this.price ? '#ffd700' : '#ff0000';
        ctx.fillText(`${this.price.toFixed(1)} Tokens`, this.x, this.y + 15);
       
        ctx.fillStyle = '#aaa';
        ctx.font = '12px Arial';
        ctx.fillText("Hold 3s", this.x, this.y + 35);
    }
}

class Box {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.color = '#5e3a18';
    }

    draw(ctx) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(this.x + (5 * game.scale), this.y + (5 * game.scale), this.w, this.h);
       
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
       
        ctx.strokeStyle = '#3e230b';
        ctx.lineWidth = 4 * game.scale;
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + this.w, this.y + this.h);
        ctx.moveTo(this.x + this.w, this.y);
        ctx.lineTo(this.x, this.y + this.h);
        ctx.stroke();
    }
}

class Entity {
    constructor(x, y, baseRadius, color) {
        this.x = x;
        this.y = y;
        this.baseRadius = baseRadius;
        this.radius = baseRadius * game.scale;
        this.color = color;
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.97;
        this.mass = this.radius;
        this.dead = false;
        this.trail = [];
        this.maxTrail = 20;
        this.teleportCooldown = 0;
    }

    updateScale() {
        let multiplier = 1 + (this.splitGrowth || 0); 
        if (this instanceof Player) multiplier *= this.statMultipliers.size;
        this.radius = this.baseRadius * game.scale * multiplier;
        this.mass = this.radius;
    }

    updateState() {
        if (this.teleportCooldown > 0) this.teleportCooldown--;

        if (gameSettings.trails) {
            if (Math.abs(this.vx) + Math.abs(this.vy) > 1) {
                this.trail.push({x: this.x, y: this.y, r: this.radius});
                if (this.trail.length > this.maxTrail) this.trail.shift();
            } else if (this.trail.length > 0) {
                this.trail.shift();
            }
        } else {
            this.trail = [];
        }

        this.vx *= this.friction;
        this.vy *= this.friction;

        if (Math.abs(this.vx) < 0.05) this.vx = 0;
        if (Math.abs(this.vy) < 0.05) this.vy = 0;
    }

    physicsStep(stepFactor) {
        this.x += (this.vx * game.slowMo) * stepFactor;
        this.y += (this.vy * game.slowMo) * stepFactor;

        this.handleWallCollision();
        this.handlePocketCollision();
        this.handleBoxCollision();
    }

    handleWallCollision() {
        let bounced = false;
        if (this.x - this.radius < BORDER_SIZE) { this.x = BORDER_SIZE + this.radius; this.vx = Math.abs(this.vx); bounced = true; }
        if (this.x + this.radius > game.width - BORDER_SIZE) { this.x = game.width - BORDER_SIZE - this.radius; this.vx = -Math.abs(this.vx); bounced = true; }
        if (this.y - this.radius < BORDER_SIZE) { this.y = BORDER_SIZE + this.radius; this.vy = Math.abs(this.vy); bounced = true; }
        if (this.y + this.radius > game.height - BORDER_SIZE) { this.y = game.height - BORDER_SIZE - this.radius; this.vy = -Math.abs(this.vy); bounced = true; }
       
        if (bounced && this instanceof Player) {
            if (this.magic8Attacking) return;

            if (this.bankShotActive > 0) {
                let speed = Math.hypot(this.vx, this.vy);
                if (speed < 40) speed = 40;
                let ang = Math.atan2(this.vy, this.vx);
                this.vx = Math.cos(ang) * speed;
                this.vy = Math.sin(ang) * speed;
                game.camera.shake = 5;
                createParticles(this.x, this.y, '#00ccff', 5, 5);
            }
            if (this.hasNitroRail) {
                let speed = Math.hypot(this.vx, this.vy);
                let ang = Math.atan2(this.vy, this.vx);
                let boost = speed * 1.5;
                this.vx = Math.cos(ang) * boost;
                this.vy = Math.sin(ang) * boost;
                createParticles(this.x, this.y, '#ffaa00', 8, 3);
            }
        }
    }

    handlePocketCollision() {
        if (this.teleportCooldown > 0) return;

        let pockets = getPockets();
        let pocketRadius = 40;

        for (let i = 0; i < pockets.length; i++) {
            let p = pockets[i];
            if (dist(this.x, this.y, p.x, p.y) < pocketRadius) {
               
                if (gameState !== 'PLAYING' && gameState !== 'CHAOS_MODE' && gameState !== 'TUTORIAL') {
                    handleHubTeleport(i);
                    return;
                }

                let targetIndex = 5 - i;
                let target = pockets[targetIndex];
               
                let centerX = game.width/2;
                let centerY = game.height/2;
                let dirX = centerX - target.x;
                let dirY = centerY - target.y;
                let len = Math.hypot(dirX, dirY);
                let offsetX = (dirX / len) * (pocketRadius + 10);
                let offsetY = (dirY / len) * (pocketRadius + 10);

                this.x = target.x + offsetX;
                this.y = target.y + offsetY;
                this.teleportCooldown = 60;
               
                createParticles(p.x, p.y, '#00ffcc', 10, 5);
                createParticles(this.x, this.y, '#00ffcc', 10, 5);
                return;
            }
        }
    }

    handleBoxCollision() {
        for (let b of boxes) {
            let testX = clamp(this.x, b.x, b.x + b.w);
            let testY = clamp(this.y, b.y, b.y + b.h);

            let distX = this.x - testX;
            let distY = this.y - testY;
            let distance = Math.sqrt(distX*distX + distY*distY);

            if (distance <= this.radius) {
                let overlap = this.radius - distance;
                let nx = distX / (distance || 1);
                let ny = distY / (distance || 1);

                if (distance === 0) { nx = 1; ny = 0; }

                this.x += nx * overlap;
                this.y += ny * overlap;

                let dot = this.vx * nx + this.vy * ny;
               
                if (this instanceof Player && this.bankShotActive > 0) {
                     this.vx = (this.vx - 2 * dot * nx);
                     this.vy = (this.vy - 2 * dot * ny);
                     let s = Math.hypot(this.vx, this.vy);
                     if (s < 40) s = 40;
                     let a = Math.atan2(this.vy, this.vx);
                     this.vx = Math.cos(a) * s;
                     this.vy = Math.sin(a) * s;
                } else {
                     this.vx = (this.vx - 2 * dot * nx) * 0.8;
                     this.vy = (this.vy - 2 * dot * ny) * 0.8;
                }
               
                createParticles(testX, testY, '#8B4513', 2, 2);
            }
        }
    }

    draw(ctx) {
        if (gameSettings.trails) {
            for (let i = 0; i < this.trail.length; i++) {
                let t = this.trail[i];
                let alpha = (i / this.trail.length) * 0.5;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, t.r * (i/this.trail.length), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
       
        if (this instanceof Player && this.iFrameTimer > 0) {
            ctx.fillStyle = (Math.floor(Date.now() / 50) % 2 === 0) ? '#ffffff' : this.color;
        } else if (this instanceof Player && this.midasCharged) {
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 30;
        } else if (this instanceof Enemy && this.freezeTimer > 0) {
            ctx.fillStyle = '#ffff00';
        } else {
            ctx.fillStyle = this.color;
        }

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
       
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.beginPath();
        ctx.arc(this.x - this.radius*0.3, this.y - this.radius*0.3, this.radius/3, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// --- EXPLODING MINI BALL ENTTIY ---
class MiniBall extends Entity {
    constructor(x, y, vx, vy) {
        super(x, y, 8, '#ffffff');
        this.vx = vx;
        this.vy = vy;
        this.damage = 100;
        this.friction = 0.99;
    }

    updateState() {
        super.updateState();
        for (let e of enemies) {
            if (dist(this.x, this.y, e.x, e.y) < this.radius + e.radius) {
                e.takeDamage(this.damage, this.x, this.y);
                this.explode();
                break;
            }
        }
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.5) this.dead = true;
    }

    explode() {
        this.dead = true;
        createParticles(this.x, this.y, '#ffffff', 15, 8);
        game.camera.shake = 8;
    }

    draw(ctx) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#fff';
        super.draw(ctx);
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 15, '#ffffff');
        this.baseAccel = 0.8;
        this.baseMaxSpeed = 15;
        this.hp = 100;
        this.maxHp = 100;
        this.damage = 10;
        this.healPerKill = 5;
       
        this.iFrameDuration = 0.2;
        this.iFrameTimer = 0;

        this.midasStacks = 0;
        this.midasCooldown = 0;
        this.midasCharged = false;
        this.midasBaseCD = 180;
        this.freezeBaseDuration = 30;

        this.regenStacks = 0;
        this.regenTimer = 0;
        this.regenInterval = 60;
       
        this.abilityCooldown = 0;
        this.abilityMaxCooldown = 180;
       
        this.scratchUnlocked = false;
        this.scratchCooldown = 0;
        this.scratchMaxCooldown = 300;
       
        this.spinUnlocked = false;
        this.spinCooldown = 0;
        this.spinMaxCooldown = 400;
        this.spinActive = 0;
        this.spinAngle = 0;

        this.streakStacks = 0;
        this.streakTimer = 0;

        this.snackStacks = 0;
        this.snackHealUsed = false;
        this.peacefulTimer = 0;

        this.hasRerollAbility = false;
        this.hasSplitAbility = false; 
        this.splitGrowth = 0;

        this.bankUnlocked = false;
        this.bankCooldown = 0;
        this.bankMaxCooldown = 780;
        this.bankShotActive = 0;

        this.chalkUnlocked = false;
        this.chalkCooldown = 0;
        this.chalkMaxCooldown = 480;
        this.chalkActive = false;
        this.chalkTargets = [];
        this.chalkTimer = 0; 

        this.nineBallUnlocked = false;
        this.nineBallCooldown = 0;
        this.nineBallMaxCooldown = 1800;

        this.magic8Unlocked = false;
        this.magic8Cooldown = 0;
        this.magic8MaxCooldown = 1800;
        this.magic8Attacking = false;
        this.magic8Targets = [];
        this.magic8TargetIndex = 0;
        this.magic8SafetyTimer = 0; 

        this.isSuperCharged = false;
        this.superChargeTimer = 0;
       
        this.dodgeChance = 0;
        this.projectileSpeedMult = 1.0;
        this.thorns = 0;
       
        this.hasCleanHit = false;
        this.cleanHitTimers = [];
        this.hasNitroRail = false;

        this.statMultipliers = {
            damage: 1 + (runBuffs.stats.damage * 0.1),
            speed: 1 + (runBuffs.stats.speed * 0.1),
            size: 1,
            defense: 1
        };

        this.maxHp += (runBuffs.stats.health * 10);
        this.hp = this.maxHp;
       
        this.updateScale();
    }

    updateMidas() {
        this.effectiveMidasCD = this.midasBaseCD - (Math.max(0, this.midasStacks - 1) * 6);
        this.effectiveFreezeDur = this.freezeBaseDuration + (Math.max(0, this.midasStacks - 1) * 15);
    }

    updateRegen() {
        this.regenInterval = 60 - (Math.max(0, this.regenStacks - 1) * 6);
    }

    unlockAllAbilities() {
        this.scratchUnlocked = true;
        this.spinUnlocked = true;
        this.bankUnlocked = true;
        this.chalkUnlocked = true;
        this.nineBallUnlocked = true;
        this.magic8Unlocked = true;
        texts.push(new FloatingText(this.x, this.y - 60, "CHEAT ENABLED!", '#ff00ff', 40));
        game.camera.shake = 20;
        document.getElementById('scratch-ui').style.display = 'flex';
        document.getElementById('spin-ui').style.display = 'flex';
        document.getElementById('bank-ui').style.display = 'flex';
        document.getElementById('chalk-ui').style.display = 'flex';
        document.getElementById('nineball-ui').style.display = 'flex';
        document.getElementById('magic8-ui').style.display = 'flex';
        document.querySelectorAll('.small-ability').forEach(el => el.style.opacity = '1');
    }

    handleWallCollision() {
        if (this.magic8Attacking) return;
        super.handleWallCollision();
    }

    handleBoxCollision() {
        if (this.magic8Attacking) return;
        super.handleBoxCollision();
    }

    resetSnack() {
        this.peacefulTimer = 0;
        this.snackHealUsed = false;
    }

    updateState() {
        this.updateScale();
       
        if (this.abilityCooldown > 0) this.abilityCooldown -= 1 * game.slowMo;
        if (this.scratchCooldown > 0) this.scratchCooldown -= 1 * game.slowMo;
        if (this.spinCooldown > 0) this.spinCooldown -= 1 * game.slowMo;
        if (this.bankCooldown > 0) this.bankCooldown -= 1 * game.slowMo;
        if (this.chalkCooldown > 0) this.chalkCooldown -= 1 * game.slowMo;
        if (this.nineBallCooldown > 0) this.nineBallCooldown -= 1 * game.slowMo;
        if (this.magic8Cooldown > 0) this.magic8Cooldown -= 1 * game.slowMo;
       
        if (this.iFrameTimer > 0) this.iFrameTimer -= 1 * game.slowMo;
        if (this.streakTimer > 0) this.streakTimer -= 1 * game.slowMo;

        if (!game.upgradePending && !game.paused) {
            this.peacefulTimer += 1 * game.slowMo;
            if (this.snackStacks > 0 && !this.snackHealUsed && this.peacefulTimer >= 120) {
                let healAmt = 10 + (this.snackStacks - 1);
                this.hp = Math.min(this.maxHp, this.hp + healAmt);
                this.snackHealUsed = true;
                createParticles(this.x, this.y, '#00ff00', 10, 5);
                texts.push(new FloatingText(this.x, this.y - 40, "SNACK BREAK! +" + healAmt, '#00ff00', 25));
            }
        }
       
        if (this.superChargeTimer > 0) {
            this.superChargeTimer -= 1 * game.slowMo;
            if (this.superChargeTimer <= 0) {
                this.isSuperCharged = false;
            }
        }

        if (this.midasStacks > 0 && !this.midasCharged) {
            this.midasCooldown += 1 * game.slowMo;
            if (this.midasCooldown >= this.effectiveMidasCD) {
                this.midasCharged = true;
                this.midasCooldown = 0;
            }
        }

        if (this.regenStacks > 0) {
            this.regenTimer += 1 * game.slowMo;
            if (this.regenTimer >= this.regenInterval) {
                this.hp = Math.min(this.maxHp, this.hp + 1);
                this.regenTimer = 0;
            }
        }

        super.updateState();

        if (this.chalkActive) {
            this.chalkTimer -= 1 * game.slowMo;
            if (this.chalkTimer <= 0 || (this.chalkTargets.length === 0 && Math.hypot(this.vx, this.vy) < 5)) {
                this.chalkActive = false;
                this.chalkTimer = 0;
                this.chalkTargets = [];
            }
        }

        if (this.magic8Attacking) {
            this.magic8SafetyTimer -= 1 * game.slowMo;
            if (this.magic8SafetyTimer <= 0) {
                this.magic8Attacking = false;
                this.magic8SafetyTimer = 0;
                gameState = (game.mode === 'CHAOS' ? 'CHAOS_MODE' : 'PLAYING');
                return;
            }

            if (this.magic8TargetIndex < this.magic8Targets.length) {
                let target = this.magic8Targets[this.magic8TargetIndex];
                if (target.dead || !enemies.includes(target)) { 
                    this.magic8TargetIndex++;
                    return;
                }
                let dx = target.x - this.x;
                let dy = target.y - this.y;
                let d = Math.sqrt(dx*dx+dy*dy);
               
                if (d < 20) {
                    target.takeDamage(25, this.x, this.y);
                    createParticles(target.x, target.y, '#000000', 15, 10);
                    game.camera.shake = 10;
                    this.magic8TargetIndex++;
                } else {
                    let ang = Math.atan2(dy, dx);
                    this.vx = Math.cos(ang) * 100;
                    this.vy = Math.sin(ang) * 100;
                }
            } else {
                this.magic8Attacking = false;
                gameState = (game.mode === 'CHAOS' ? 'CHAOS_MODE' : 'PLAYING');
               
                let s = Math.hypot(this.vx, this.vy);
                if (s > 30) {
                    let scale = 30/s;
                    this.vx *= scale;
                    this.vy *= scale;
                }
            }
            return;
        }

        for (let i = this.cleanHitTimers.length - 1; i >= 0; i--) {
            this.cleanHitTimers[i]--;
            if (this.cleanHitTimers[i] <= 0) this.cleanHitTimers.splice(i, 1);
        }
        let bonusSpeed = (this.cleanHitTimers.length * 0.04);

        let currentScale = game.scale;
        let scaledAccel = this.baseAccel * currentScale * this.statMultipliers.speed;
        let scaledMaxSpeed = this.baseMaxSpeed * currentScale * this.statMultipliers.speed * (1 + bonusSpeed);

        if (game.hitStop <= 0 && !game.upgradePending) {
            if (this.spinActive > 0) {
                this.spinActive--;
                this.spinAngle += 0.5;
                this.vx = Math.cos(this.spinAngle) * (scaledMaxSpeed * 2.5);
                this.vy = Math.sin(this.spinAngle) * (scaledMaxSpeed * 2.5);
            } else if (this.bankShotActive > 0) {
                this.bankShotActive--;
                createParticles(this.x, this.y, '#00ccff', 2, 5);
                if (keys.w) this.vy -= scaledAccel;
                if (keys.s) this.vy += scaledAccel;
                if (keys.a) this.vx -= scaledAccel;
                if (keys.d) this.vx += scaledAccel;
            } else {
                if (keys.w) this.vy -= scaledAccel;
                if (keys.s) this.vy += scaledAccel;
                if (keys.a) this.vx -= scaledAccel;
                if (keys.d) this.vx += scaledAccel;
            }
        }

        let speed = Math.hypot(this.vx, this.vy);
        let cap = this.isSuperCharged ? 80 : scaledMaxSpeed;
        if (this.spinActive > 0) cap = 120;
        if (this.bankShotActive > 0) cap = 60;
        if (this.chalkActive) cap = 120;

        if (speed > cap) {
            let scale = cap / speed;
            this.vx *= scale;
            this.vy *= scale;
        }
    }

    activateAbility() {
        if (gameState !== 'PLAYING' && gameState !== 'CHAOS_MODE' && gameState !== 'MENU' && gameState !== 'SHOP_STATS' && gameState !== 'SHOP_CARDS' && gameState !== 'TUTORIAL' && gameState !== 'SETTINGS') return;
       
        if (gameState === 'TUTORIAL') {
            if (tutorial.step === 4 || tutorial.step === 6) return;
            if (tutorial.step === 0) {
                tutorial.step = 1;
                showTutorialStep(1);
            }
        }

        if (this.abilityCooldown > 0) return;
       
        let nearest = null;
        let minDst = Infinity;
        enemies.forEach(e => {
            let d = dist(this.x, this.y, e.x, e.y);
            if (d < minDst) {
                minDst = d;
                nearest = e;
            }
        });

        let ang = 0;
        if (!nearest) {
             ang = Math.atan2(this.vy, this.vx);
             if (this.vx === 0 && this.vy === 0) ang = -Math.PI/2;
        } else {
             let dx = nearest.x - this.x;
             let dy = nearest.y - this.y;
             ang = Math.atan2(dy, dx);
        }

        this.abilityCooldown = this.abilityMaxCooldown;
        game.slowMo = 0.1;
        setTimeout(() => { game.slowMo = 1.0; }, 300);
       
        createCueVisual(this.x, this.y, ang);

        let launchSpeed = 60 * game.scale * this.projectileSpeedMult;

        this.vx = Math.cos(ang) * launchSpeed;
        this.vy = Math.sin(ang) * launchSpeed;
        this.isSuperCharged = true;
        this.superChargeTimer = 90;
        game.camera.shake = 30;
    }

    activateScratch() {
        if (!this.scratchUnlocked || this.scratchCooldown > 0) return;
       
        let pockets = getPockets();
        let maxDist = -1;
        let target = pockets[0];

        pockets.forEach(p => {
            let d = dist(this.x, this.y, p.x, p.y);
            if (d > maxDist) {
                maxDist = d;
                target = p;
            }
        });

        createParticles(this.x, this.y, '#00ff00', 20, 10);
       
        let centerX = game.width/2;
        let centerY = game.height/2;
        let dirX = centerX - target.x;
        let dirY = centerY - target.y;
        let len = Math.hypot(dirX, dirY);
        let offsetX = (dirX / len) * 60;
        let offsetY = (dirY / len) * 60;

        this.x = target.x + offsetX;
        this.y = target.y + offsetY;
        this.vx = 0;
        this.vy = 0;

        createParticles(this.x, this.y, '#00ff00', 20, 10);
        this.scratchCooldown = this.scratchMaxCooldown;
        game.camera.shake = 10;
    }

    activateSpin() {
        if (gameState === 'TUTORIAL' && tutorial.step === 4) {
            this.spinActive = 90;
            game.camera.shake = 5;
            return;
        }

        if (!this.spinUnlocked || this.spinCooldown > 0) return;
        this.spinActive = 90;
        this.spinCooldown = this.spinMaxCooldown;
        game.camera.shake = 5;
    }

    activateBank() {
        if (!this.bankUnlocked || this.bankCooldown > 0) return;
        this.bankShotActive = 300;
        this.bankCooldown = this.bankMaxCooldown;
        game.camera.shake = 10;
       
        let speed = Math.hypot(this.vx, this.vy);
        if (speed < 10) speed = 10;
        let ang = Math.atan2(this.vy, this.vx);
        this.vx = Math.cos(ang) * 50;
        this.vy = Math.sin(ang) * 50;
    }

    activateChalk() {
        if (!this.chalkUnlocked || this.chalkCooldown > 0) return;
       
        let sorted = enemies.slice().sort((a,b) => dist(this.x,this.y,a.x,a.y) - dist(this.x,this.y,b.x,b.y));
        this.chalkTargets = sorted.slice(0, 3);
       
        if (this.chalkTargets.length > 0) {
            this.chalkActive = true;
            this.chalkTimer = 180; 
            this.chalkCooldown = this.chalkMaxCooldown;
            this.launchAtNextChalkTarget();
        }
    }
   
    activateNineBall() {
        if (!this.nineBallUnlocked || this.nineBallCooldown > 0) return;
        this.nineBallCooldown = this.nineBallMaxCooldown;
        game.camera.shake = 20;
       
        let sorted = enemies.slice().sort((a,b) => dist(this.x,this.y,a.x,a.y) - dist(this.x,this.y,b.x,b.y));
        let targets = sorted.slice(0, 9);
       
        targets.forEach(e => {
            e.takeDamage(9999, e.x, e.y);
            createParticles(e.x, e.y, '#ffee00', 10, 5);
        });
       
        texts.push(new FloatingText(this.x, this.y - 60, "9 BALL BREAK!", '#ffee00', 30));
    }

    activateMagic8() {
        if (!this.magic8Unlocked || this.magic8Cooldown > 0) return;
        this.magic8Cooldown = this.magic8MaxCooldown;
        gameState = 'CUTSCENE_MAGIC8';
        cutscene.active = true;
        cutscene.timer = 0;
        cutscene.phase = 0;
        cutscene.text = '';
        cutscene.outcome = Math.random() < 0.4 ? 'SUCCESS' : 'FAIL';
    }

    launchAtNextChalkTarget() {
        if (this.chalkTargets.length === 0) {
            this.chalkActive = false;
            this.vx *= 0.2;
            this.vy *= 0.2;
            return;
        }

        let target = this.chalkTargets.shift();
        if (target.dead || !enemies.includes(target)) {
            this.launchAtNextChalkTarget();
            return;
        }

        let dx = target.x - this.x;
        let dy = target.y - this.y;
        let ang = Math.atan2(dy, dx);
       
        this.vx = Math.cos(ang) * 80;
        this.vy = Math.sin(ang) * 80;
       
        createParticles(this.x, this.y, '#ff55ff', 20, 10);
    }
   
    takeDamage(amount, attacker = null) {
        if (this.iFrameTimer > 0) return;
        this.resetSnack();

        if (this.midasCharged && attacker instanceof Enemy) {
            this.midasCharged = false;
            attacker.freezeTimer = this.effectiveFreezeDur;
            attacker.vx = 0;
            attacker.vy = 0;
            createParticles(attacker.x, attacker.y, '#ffff00', 10, 5);
            texts.push(new FloatingText(attacker.x, attacker.y - 30, "MIDAS FREEZE", '#ffff00', 20));
            this.iFrameTimer = 20;
            return;
        }

        if (Math.random() < this.dodgeChance) {
            texts.push(new FloatingText(this.x, this.y - 30, "DODGE", '#aaa', 20));
            return;
        }

        let actualDmg = Math.max(1, amount / this.statMultipliers.defense);
        actualDmg = Math.min(actualDmg, this.maxHp * 0.2);

        this.hp -= actualDmg;
        game.camera.shake = 10;

        if (this.iFrameDuration > 0) {
            this.iFrameTimer = this.iFrameDuration * 60;
        }
       
        if (this.hp <= 0) {
            this.hp = 0;
            gameOver();
        }
    }

    onKill() {
        this.hp = Math.min(this.hp + this.healPerKill, this.maxHp);
        texts.push(new FloatingText(this.x, this.y - 30, `+${this.healPerKill} HP`, '#00ff00', 20));
       
        if (this.hasCleanHit) {
            if (this.cleanHitTimers.length < 5) {
                this.cleanHitTimers.push(120);
            }
        }

        if (this.streakStacks > 0) {
            this.streakTimer = (0.3 + (this.streakStacks - 1) * 0.2) * 60;
        }

        if (this.hasSplitAbility) {
            this.splitGrowth += 0.1;
            if (this.splitGrowth >= 0.5) { 
                this.splitGrowth = 0; 
                this.spawnMiniBalls(); 
                texts.push(new FloatingText(this.x, this.y - 50, "SPLIT!", '#ffd700', 35));
            }
        }
    }

    spawnMiniBalls() {
        for (let i = 0; i < 2; i++) {
            let angle = Math.random() * Math.PI * 2;
            let spd = 15;
            miniBalls.push(new MiniBall(this.x, this.y, Math.cos(angle) * spd, Math.sin(angle) * spd));
        }
    }

    draw(ctx) {
        super.draw(ctx);
        if (this.streakTimer > 0) {
            ctx.save();
            ctx.shadowBlur = 40;
            ctx.shadowColor = '#ff0000';
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
        }
        if (this.isSuperCharged) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = 40;
            ctx.shadowColor = '#00ffff';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
        }
        if (this.spinActive > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ffaa00';
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            let spiralX = this.x;
            let spiralY = this.y;
            ctx.moveTo(spiralX, spiralY);
            for(let i=0; i<Math.PI*4; i+=0.5) {
                let r = i * (this.radius + 10);
                ctx.lineTo(spiralX + Math.cos(this.spinAngle + i)*r, spiralY + Math.sin(this.spinAngle + i)*r);
            }
            ctx.stroke();
            ctx.restore();
        }
        if (this.bankShotActive > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = 40;
            ctx.shadowColor = '#00ccff';
            ctx.strokeStyle = '#00ccff';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 8, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
        }
        if (this.chalkActive) {
            ctx.save();
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff55ff';
            ctx.strokeStyle = '#ff55ff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
        }
        if (this.magic8Attacking) {
            ctx.save();
            ctx.shadowBlur = 50;
            ctx.shadowColor = '#000';
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.restore();
        }
    }
}

class Enemy extends Entity {
    constructor(x, y, level) {
        let baseR = 15 + (level * 0.5);
        super(x, y, baseR, `hsl(${Math.random()*360}, 90%, 60%)`);
        this.hp = 20 + (level * 5);
        this.maxHp = this.hp;
        this.damage = 10 + (level * 1.5);
        this.level = level;
        this.number = Math.ceil(Math.random() * 15);
        this.friction = 0.98;
        this.freezeTimer = 0;
        this.updateScale();
    }

    updateState() {
        this.updateScale();
        super.updateState();

        if (this.freezeTimer > 0) {
            this.freezeTimer -= 1 * game.slowMo;
            this.vx = 0;
            this.vy = 0;
            return;
        }
       
        if (gameState === 'TUTORIAL' && tutorial.step < 6) return;

        if (player && !this.dead) {
            let dx = player.x - this.x;
            let dy = player.y - this.y;
            let d = Math.hypot(dx, dy);
           
            let speedFactor = Math.min(0.8, 0.2 + (this.level * 0.03));
           
            if (d > 0) {
                this.vx += (dx / d) * (speedFactor * game.scale);
                this.vy += (dy / d) * (speedFactor * game.scale);
            }
        }
       
        let speed = Math.hypot(this.vx, this.vy);
        let cap = 25; 
        if (speed > cap) {
            let scale = cap / speed;
            this.vx *= scale;
            this.vy *= scale;
        }
    }

    takeDamage(amount, impactX, impactY) {
        this.hp -= amount;
        texts.push(new FloatingText(this.x, this.y - 20, Math.floor(amount), '#ffcc00', 20 + Math.min(amount, 30)));
        this.flash = 5;
        if (this.hp <= 0) this.die();
    }

    die() {
        this.dead = true;
        player.onKill();
        game.camera.shake = 15;
        createParticles(this.x, this.y, this.color, 20, 30);
        createParticles(this.x, this.y, '#ffffff', 10, 20);
    }

    draw(ctx) {
        if (this.flash > 0 && gameSettings.impactFrames) {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
            ctx.fill();
            this.flash--;
            return;
        }

        super.draw(ctx);
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.6, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = `bold ${Math.max(10, 12 * game.scale)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.number, this.x, this.y);
    }
}

let player;
let enemies = [];
let particles = [];
let boxes = [];
let texts = [];
let cues = [];
let shopItems = [];
let miniBalls = []; 
let chaosChoicesMade = 0;

function init() {
    loadData();
    resize();
    window.addEventListener('resize', resize);
    returnToMenu();
    loop();
}

function resize() {
    game.width = window.innerWidth;
    game.height = window.innerHeight;
    CANVAS.width = game.width;
    CANVAS.height = game.height;
   
    if (player) {
        player.x = clamp(player.x, BORDER_SIZE + 50, game.width - BORDER_SIZE - 50);
        player.y = clamp(player.y, BORDER_SIZE + 50, game.height - BORDER_SIZE - 50);
    }
}

function getPockets() {
    return [
        {x: 50, y: 50, label: "SHOP"},
        {x: game.width/2, y: 45, label: "PLAY"},
        {x: game.width-50, y: 50, label: "CARDS"},
        {x: 50, y: game.height-50, label: "SETTINGS"},
        {x: game.width/2, y: game.height-45, label: "TUTORIAL"},
        {x: game.width-50, y: game.height-50, label: "CHAOS"}
    ];
}

function handleHubTeleport(index) {
    if (gameState === 'MENU') {
        if (index === 0) loadShop('STATS');
        else if (index === 1) startGame('NORMAL');
        else if (index === 2) loadShop('CARDS');
        else if (index === 3) loadSettings();
        else if (index === 4) startTutorial();
        else if (index === 5) startGame('CHAOS');
    } else if (gameState.startsWith('SHOP') || gameState === 'SETTINGS') {
        if (index === 4) returnToMenu();
    }
}

function returnToMenu() {
    gameState = 'MENU';
    game.mode = 'NORMAL';
    game.active = true;
    game.level = 1;
    game.scale = 1.0;
    game.slowMo = 1.0;
   
    document.getElementById('game-over-screen').style.display = 'none';
    document.getElementById('tutorial-text').style.display = 'block';
    document.getElementById('tutorial-text').innerHTML = "<h1>MAIN MENU</h1><h2>TL: STATS | TM: PLAY | TR: CARDS | BL: SETTINGS | BM: TUTORIAL | BR: CHAOS</h2>";
    document.getElementById('game-ui').style.display = 'none';
    document.getElementById('level-display').innerText = "MENU";
    document.getElementById('best-run-display').innerText = `BEST: ${globalBestRun}`;
    document.getElementById('best-run-display').style.display = 'block';
    document.getElementById('speed-display').style.display = 'none';
    document.getElementById('tutorial-dialogue').style.display = 'none';
    document.getElementById('upgrade-overlay').style.display = 'none';

    enemies = [];
    boxes = [];
    particles = [];
    shopItems = [];
    miniBalls = [];

    // FIX: Reset the run data so you don't start with old buffs
    resetRunState();

    player = new Player(game.width / 2, game.height / 2 + 100);
}

function startTutorial() {
    gameState = 'TUTORIAL';
    game.mode = 'NORMAL';
    tutorial.step = 0;
    tutorial.clickPending = false;
    enemies = [];
    shopItems = [];
    boxes = [];
    miniBalls = [];
   
    document.getElementById('tutorial-text').style.display = 'none';
    document.getElementById('game-ui').style.display = 'flex';
    document.getElementById('level-display').innerText = "TUTORIAL";
    document.getElementById('best-run-display').style.display = 'none';
   
    player.x = 150;
    player.y = game.height/2;
    player.vx = 0; player.vy = 0;
   
    enemies.push(new Enemy(game.width/2 + 200, game.height/2, 1));
    showTutorialStep(0);
}

function showTutorialStep(step) {
    let dia = document.getElementById('tutorial-dialogue');
    let text = document.getElementById('tutorial-text-content');
    let prompt = document.getElementById('click-prompt');
   
    dia.style.display = 'block';
    tutorial.clickPending = false;
    prompt.style.display = 'none';

    switch(step) {
        case 0: text.innerHTML = "Welcome! Press <span style='color:#00ffcc'>[SPACE]</span> to use Cue Strike on this dummy."; break;
        case 1: text.innerHTML = "<span style='color:#00ff00'>Good job!</span>"; setTimeout(() => { tutorial.step = 2; showTutorialStep(2); }, 2000); break;
        case 2: text.innerHTML = "Rule #1: You heal <span style='color:#00ff00'>5 HP</span> every time you get a kill."; prompt.style.display = 'block'; tutorial.clickPending = true; break;
        case 3: text.innerHTML = "Rule #2: You unlock powerful abilities at Levels 5, 10, 20, 25, 30, and 40."; prompt.style.display = 'block'; tutorial.clickPending = true; break;
        case 4: text.innerHTML = "Try the <span style='color:#ffaa00'>SPIN [Q]</span> ability on this target!<br><span style='color:red'>(Cue Strike Disabled)</span>"; enemies = []; enemies.push(new Enemy(game.width/2 + 200, game.height/2, 1)); document.getElementById('spin-ui').style.display = 'flex'; document.getElementById('spin-ui').style.opacity = '1'; break;
        case 5: text.innerHTML = "Physics Rule: To deal RAM damage, you must be <b>FASTER</b> than the enemy.<br>If you are slower, <b>YOU</b> take damage."; prompt.style.display = 'block'; tutorial.clickPending = true; break;
        case 6: text.innerHTML = "Defeat this MOVING target!<br><span style='color:red'>(Cue Strike & Spin Disabled)</span>"; enemies = []; enemies.push(new Enemy(game.width/2 + 200, game.height/2, 1)); break;
        case 7: text.innerHTML = "After beating a level, you get an Upgrade."; prompt.style.display = 'block'; tutorial.clickPending = true; break;
        case 8: dia.style.display = 'none'; showUpgradeMenu(true); break;
        case 9: dia.style.display = 'block'; text.innerHTML = "You earn <span style='color:gold'>Tokens</span> based on levels survived.<br>Buy persistent buffs in the Shop.<br>Buffs last for 1 run."; prompt.style.display = 'block'; tutorial.clickPending = true; break;
        case 10: text.innerHTML = "That's all! Good luck!"; prompt.style.display = 'block'; tutorial.clickPending = true; break;
    }
}

function advanceTutorial() {
    if (tutorial.step === 2) { tutorial.step = 3; showTutorialStep(3); }
    else if (tutorial.step === 3) { tutorial.step = 4; showTutorialStep(4); }
    else if (tutorial.step === 5) { tutorial.step = 6; showTutorialStep(6); }
    else if (tutorial.step === 7) { tutorial.step = 8; showTutorialStep(8); }
    else if (tutorial.step === 9) { tutorial.step = 10; showTutorialStep(10); }
    else if (tutorial.step === 10) returnToMenu();
}

function loadSettings() {
    gameState = 'SETTINGS';
    enemies = []; boxes = []; particles = []; shopItems = [];
    document.getElementById('tutorial-text').innerHTML = `<h1>SETTINGS</h1><h2>Roll into circles to toggle. Bottom-Mid Pocket to Exit.</h2>`;
    document.getElementById('level-display').innerText = "SETTINGS";
    player.x = game.width/2; player.y = game.height/2; player.vx = 0; player.vy = 0;
    shopItems.push(new ToggleZone(game.width/2 - 200, game.height/2, 'particles', 'PARTICLES'));
    shopItems.push(new ToggleZone(game.width/2, game.height/2 - 100, 'trails', 'TRAILS'));
    shopItems.push(new ToggleZone(game.width/2 + 200, game.height/2, 'impactFrames', 'FLASH'));
}

function loadShop(type) {
    gameState = (type === 'STATS') ? 'SHOP_STATS' : 'SHOP_CARDS';
    enemies = []; boxes = []; particles = []; shopItems = [];
    document.getElementById('tutorial-text').innerHTML = `<h1>${type} SHOP</h1><h2>Roll on circle & hold 3s to buy. Bottom-Mid Pocket to Exit.</h2>`;
    document.getElementById('level-display').innerText = "SHOP";
    player.x = game.width/2; player.y = game.height/2; player.vx = 0; player.vy = 0;
    if (type === 'STATS') {
        shopItems.push(new ShopZone(game.width/2 - 200, game.height/2, 'STAT', {stat: 'speed'}, 0));
        shopItems.push(new ShopZone(game.width/2, game.height/2 - 100, 'STAT', {stat: 'health'}, 1));
        shopItems.push(new ShopZone(game.width/2 + 200, game.height/2, 'STAT', {stat: 'damage'}, 2));
    } else {
        for (let i=0; i<3; i++) {
            let card = pickWeightedCard();
            shopItems.push(new ShopZone(game.width/2 + (i-1)*250, game.height/2, 'CARD', {card: card}, i));
        }
    }
}

function startGame(mode) {
    game.mode = mode;
    gameState = (mode === 'CHAOS' ? 'CHAOS_MODE' : 'PLAYING');
    game.level = 1;
    game.active = true;
    game.paused = false;
    document.getElementById('game-over-screen').style.display = 'none';
    document.getElementById('tutorial-text').style.display = 'none';
    document.getElementById('game-ui').style.display = 'flex';
    document.getElementById('speed-display').style.display = 'block';
   
    player = new Player(game.width / 2, game.height / 2);
   
    document.getElementById('scratch-ui').style.display = 'none';
    document.getElementById('spin-ui').style.display = 'none';
    document.getElementById('bank-ui').style.display = 'none';
    document.getElementById('chalk-ui').style.display = 'none';
    document.getElementById('nineball-ui').style.display = 'none';
    document.getElementById('magic8-ui').style.display = 'none';
   
    setupLevel();
}

function setupLevel() {
    game.scale = getGlobalScale();
    game.rerollSpentThisLevel = false;
    document.getElementById('reroll-btn').style.display = 'none';

    enemies = []; boxes = []; particles = []; texts = []; shopItems = []; miniBalls = [];
   
    if (game.level >= 5) { player.scratchUnlocked = true; document.getElementById('scratch-ui').style.display = 'flex'; document.getElementById('scratch-ui').style.opacity = '1'; }
    if (game.level >= 10) { player.spinUnlocked = true; document.getElementById('spin-ui').style.display = 'flex'; document.getElementById('spin-ui').style.opacity = '1'; }
    if (game.level >= 20) { player.bankUnlocked = true; document.getElementById('bank-ui').style.display = 'flex'; document.getElementById('bank-ui').style.opacity = '1'; }
    if (game.level >= 25) { player.nineBallUnlocked = true; document.getElementById('nineball-ui').style.display = 'flex'; document.getElementById('nineball-ui').style.opacity = '1'; }
    if (game.level >= 30) { player.chalkUnlocked = true; document.getElementById('chalk-ui').style.display = 'flex'; document.getElementById('chalk-ui').style.opacity = '1'; }
    if (game.level >= 40) { player.magic8Unlocked = true; document.getElementById('magic8-ui').style.display = 'flex'; document.getElementById('magic8-ui').style.opacity = '1'; }

    player.x = 150; player.y = game.height / 2; player.vx = 0; player.vy = 0;
   
    let numBoxes = game.mode === 'CHAOS' ? 5 : Math.min(5 + Math.floor(game.level / 2), 15);
    for (let i=0; i<numBoxes; i++) {
        let w = rand(50, 150) * game.scale; let h = rand(50, 150) * game.scale;
        let x = rand(200, game.width - 200); let y = rand(100, game.height - 100);
        boxes.push(new Box(x, y, w, h));
    }

    let numEnemies = game.mode === 'CHAOS' ? game.level * 2 : game.level;
    for (let i = 0; i < numEnemies; i++) {
        let ex, ey, safe;
        do {
            safe = true; ex = rand(BorderSpace(), game.width - BorderSpace()); ey = rand(BorderSpace(), game.height - BorderSpace());
            for (let b of boxes) { if (ex > b.x - 20 && ex < b.x + b.w + 20 && ey > b.y - 20 && ey < b.y + b.h + 20) safe = false; }
        } while (!safe);
        enemies.push(new Enemy(ex, ey, game.level));
    }
    document.getElementById('level-display').innerText = `${game.mode === 'CHAOS' ? 'CHAOS ' : ''}Level: ${game.level}`;
}

function BorderSpace() { return 400 * game.scale; }

function createParticles(x, y, color, count, speedVar) {
    if (!gameSettings.particles) return;
    for (let i = 0; i < count; i++) particles.push(new Particle(x, y, color, speedVar, rand(2, 6), 1.0));
}

function createCueVisual(x, y, angle) {
    cues.push({
        x: x, y: y, angle: angle, life: 10,
        draw: function(ctx) {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.translate(-40 * game.scale, 0);
            ctx.shadowBlur = 20; ctx.shadowColor = '#00ffff'; let s = game.scale;
            ctx.fillStyle = '#deb887'; ctx.fillRect(-200 * s, -5 * s, 200 * s, 10 * s);
            ctx.fillStyle = '#00ccff'; ctx.fillRect(-5 * s, -5 * s, 5 * s, 10 * s);
            ctx.restore(); this.life--;
        }
    });
}

function resolveCollisions() {
    let streakMult = (player.streakTimer > 0) ? 1.5 : 1.0;

    for (let e of enemies) {
        let dx = e.x - player.x; let dy = e.y - player.y; let distVal = Math.sqrt(dx*dx + dy*dy); let minDist = player.radius + e.radius;
        if (distVal < minDist) {
            player.resetSnack();
            let pSpeed = Math.hypot(player.vx, player.vy); let eSpeed = Math.hypot(e.vx, e.vy);
            let angle = Math.atan2(dy, dx); let overlap = minDist - distVal;
            let totalMass = player.mass + e.mass; let m1 = e.mass / totalMass; let m2 = player.mass / totalMass;
            let moveX = Math.cos(angle) * overlap; let moveY = Math.sin(angle) * overlap;

            player.x -= moveX * m1; player.y -= moveY * m1;
            e.x += moveX * m2; e.y += moveY * m2;

            let vCollision = { x: e.vx - player.vx, y: e.vy - player.vy };
            let vNormal = { x: dx/(distVal||1), y: dy/(distVal||1) };
            let velAlongNormal = vCollision.x * vNormal.x + vCollision.y * vNormal.y;
            if (velAlongNormal > 0) continue;

            let j = -(1 + 0.9) * velAlongNormal; j /= (1/player.mass + 1/e.mass);
            let impulse = { x: j * vNormal.x, y: j * vNormal.y };
            player.vx -= impulse.x / player.mass; player.vy -= impulse.y / player.mass;
            e.vx += impulse.x / e.mass; e.vy += impulse.y / e.mass;

            let impactForce = Math.abs(velAlongNormal);
            if (player.thorns > 0) e.takeDamage(player.thorns, e.x, e.y);

            if (player.spinActive > 0) { e.takeDamage(player.damage * 5 * player.statMultipliers.damage * streakMult, e.x, e.y); game.camera.shake = 10;
            } else if (player.bankShotActive > 0) { e.takeDamage(player.damage * 2 * player.statMultipliers.damage * streakMult, e.x, e.y);
            } else if (player.chalkActive) { e.takeDamage(player.damage * 3 * player.statMultipliers.damage * streakMult, e.x, e.y); player.launchAtNextChalkTarget();
            } else if (player.isSuperCharged) { e.takeDamage(player.damage * 10 * player.statMultipliers.damage * streakMult, e.x, e.y); game.camera.shake = 40; game.hitStop = 2; game.impactFrame = 1;
                player.isSuperCharged = false; player.superChargeTimer = 0;
            } else if (impactForce > 2 * game.scale) {
                let speedDiff = pSpeed - eSpeed;
                if (speedDiff > 2) e.takeDamage((player.damage * (impactForce / 5) * player.statMultipliers.damage * streakMult), e.x, e.y);
                else player.takeDamage((e.damage * (impactForce / 12)), e);
            }
        }
    }

    for (let i = 0; i < enemies.length; i++) {
        for (let j = i + 1; j < enemies.length; j++) {
            let e1 = enemies[i]; let e2 = enemies[j];
            let dx = e2.x - e1.x; let dy = e2.y - e1.y; let d = Math.sqrt(dx*dx + dy*dy);
            if (d < e1.radius + e2.radius) {
                let overlap = (e1.radius + e2.radius - d) / 2; let nx = dx/(d||1); let ny = dy/(d||1);
                e1.x -= nx * overlap; e1.y -= ny * overlap; e2.x += nx * overlap; e2.y += ny * overlap;
                let tempVx = e1.vx; let tempVy = e1.vy; e1.vx = e2.vx * 0.9; e1.vy = e2.vy * 0.9; e2.vx = tempVx * 0.9; e2.vy = tempVy * 0.9;
            }
        }
    }
}

function loop() {
    requestAnimationFrame(loop);
    if (game.hitStop > 0) { game.hitStop--; return; }
    if (game.upgradePending) return;

    let shakeX = (Math.random() - 0.5) * game.camera.shake;
    let shakeY = (Math.random() - 0.5) * game.camera.shake;
    game.camera.shake *= 0.85;

    if (gameState === 'CUTSCENE_MAGIC8') {
        cutscene.timer++;
        if (cutscene.timer < 60) game.camera.shake = 5;
        else if (cutscene.timer === 90) cutscene.text = cutscene.outcome === 'SUCCESS' ? "THE ODDS ARE IN YOUR FAVOR" : "NOT TODAY";
        else if (cutscene.timer > 150) {
            gameState = (game.mode === 'CHAOS' ? 'CHAOS_MODE' : 'PLAYING'); cutscene.active = false;
            if (cutscene.outcome === 'SUCCESS') { 
                player.magic8Attacking = true; 
                player.magic8Targets = enemies.slice(); 
                player.magic8TargetIndex = 0; 
                player.magic8SafetyTimer = 360; 
            }
        }
        drawLayer(CTX, shakeX, shakeY);
        CTX.save(); CTX.fillStyle = 'rgba(0,0,0,0.8)'; CTX.fillRect(0,0,game.width, game.height);
        let cx = game.width/2; let cy = game.height/2;
        if (cutscene.timer < 60) { cx += (Math.random()-0.5)*20; cy += (Math.random()-0.5)*20; }
        CTX.fillStyle = '#000'; CTX.beginPath(); CTX.arc(cx, cy, 100, 0, Math.PI*2); CTX.fill();
        CTX.fillStyle = '#111'; CTX.beginPath(); CTX.arc(cx, cy, 40, 0, Math.PI*2); CTX.fill();
        if (cutscene.timer >= 90) {
            CTX.fillStyle = '#0000ff'; CTX.beginPath(); CTX.moveTo(cx, cy - 20); CTX.lineTo(cx + 20, cy + 10); CTX.lineTo(cx - 20, cy + 10); CTX.fill();
            CTX.fillStyle = '#fff'; CTX.font = 'bold 16px Arial'; CTX.textAlign = 'center'; CTX.fillText(cutscene.text, cx, cy + 50);
        }
        CTX.restore(); return;
    }

    if (gameState === 'PLAYING' || gameState === 'CHAOS_MODE' || gameState === 'TUTORIAL' || gameState === 'MAGIC8_ATTACK') {
        player.updateState(); enemies.forEach(e => e.updateState()); 
        miniBalls.forEach(m => m.updateState()); 

        let stepFactor = 1.0 / PHYSICS_STEPS;
        for (let s = 0; s < PHYSICS_STEPS; s++) { 
            player.physicsStep(stepFactor); 
            enemies.forEach(e => e.physicsStep(stepFactor)); 
            miniBalls.forEach(m => m.physicsStep(stepFactor)); 
            resolveCollisions(); 
        }
        enemies = enemies.filter(e => !e.dead);
        miniBalls = miniBalls.filter(m => !m.dead);

        if ((gameState === 'PLAYING' || gameState === 'CHAOS_MODE') && enemies.length === 0 && !game.upgradePending && !player.magic8Attacking) levelComplete();
        if (gameState === 'TUTORIAL' && (tutorial.step === 4 || tutorial.step === 6) && enemies.length === 0) { tutorial.step++; showTutorialStep(tutorial.step); }
    } else { player.updateState(); player.physicsStep(1.0); }
   
    shopItems.forEach(s => s.update());
    particles.forEach((p, i) => { p.update(); if (p.life <= 0) particles.splice(i, 1); });
    texts.forEach((t, i) => { t.update(); if (t.life <= 0) texts.splice(i, 1); });

    drawLayer(CTX, shakeX, shakeY);
    if (game.camera.shake > 5 && gameSettings.impactFrames) {
        CTX.save(); CTX.globalCompositeOperation = 'screen'; CTX.globalAlpha = 0.5;
        CTX.translate(5, 0); drawLayer(CTX, shakeX, shakeY, 'red'); CTX.translate(-10, 0); drawLayer(CTX, shakeX, shakeY, 'blue'); CTX.restore();
    }
    if (game.impactFrame > 0 && gameSettings.impactFrames) { CTX.fillStyle = `rgba(255, 255, 255, 0.7)`; CTX.fillRect(0, 0, game.width, game.height); game.impactFrame--; }
    updateUI();
}

function drawLayer(ctx, sx, sy, tint = null) {
    ctx.save(); ctx.translate(sx, sy);
    if (!tint) { ctx.fillStyle = '#1e1e1e'; ctx.fillRect(0, 0, game.width, game.height); }
    ctx.fillStyle = tint ? (tint === 'red' ? '#500' : '#005') : '#0f380f';
    ctx.fillRect(50, 50, game.width - 100, game.height - 100);
   
    ctx.strokeStyle = '#144514'; ctx.lineWidth = 2; ctx.beginPath();
    for(let i=50; i<game.width-50; i+=100*game.scale) { ctx.moveTo(i, 50); ctx.lineTo(i, game.height-50); }
    for(let i=50; i<game.height-50; i+=100*game.scale) { ctx.moveTo(50, i); ctx.lineTo(game.width-50, i); }
    ctx.stroke();

    ctx.fillStyle = '#3e230b'; ctx.fillRect(0, 0, game.width, 50); ctx.fillRect(0, game.height-50, game.width, 50); ctx.fillRect(0, 0, 50, game.height); ctx.fillRect(game.width-50, 0, 50, game.height);
   
    let pockets = getPockets();
    pockets.forEach((p, i) => {
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x, p.y, 35 * game.scale, 0, Math.PI*2); ctx.fill();
        if (!tint) {
            ctx.fillStyle = 'white'; ctx.font = '16px Black Ops One'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            if (gameState === 'MENU') {
                ctx.fillText(p.label, p.x, p.y);
            } else if (gameState.startsWith('SHOP') || gameState === 'SETTINGS') {
                if (i === 4) ctx.fillText("EXIT", p.x, p.y - 50);
            }
        }
    });

    if (!tint) {
        shopItems.forEach(s => s.draw(ctx)); 
        boxes.forEach(b => b.draw(ctx)); 
        miniBalls.forEach(m => m.draw(ctx)); 
        player.draw(ctx);
        enemies.forEach(e => e.draw(ctx)); 
        particles.forEach(p => p.draw(ctx)); 
        texts.forEach(t => t.draw(ctx));
        for (let i = cues.length - 1; i >= 0; i--) { cues[i].draw(ctx); if (cues[i].life <= 0) cues.splice(i, 1); }
    } else {
        shopItems.forEach(s => s.draw(ctx)); boxes.forEach(b => b.draw(ctx)); player.draw(ctx);
        enemies.forEach(e => e.draw(ctx)); particles.forEach(p => p.draw(ctx));
    }
    ctx.restore();
}

function updateUI() {
    document.getElementById('token-display').innerText = `TOKENS: ${globalTokens.toFixed(1)}`;
    if (gameState !== 'PLAYING' && gameState !== 'CHAOS_MODE' && gameState !== 'TUTORIAL') return;
    document.getElementById('speed-display').innerText = `${Math.floor(Math.hypot(player.vx, player.vy) * 5)} IN/S`;
    document.getElementById('health-display').innerText = `HP: ${Math.ceil(player.hp)}`;
    let ratio = 1 - (player.abilityCooldown / player.abilityMaxCooldown);
    document.getElementById('ability-fill').style.width = `${ratio * 100}%`;
    let text = document.getElementById('ability-text');
    if (ratio >= 1) { text.innerText = "CUE STRIKE READY [SPACE]"; text.style.color = "#00ffcc"; text.style.textShadow = "0 0 10px #00ffcc"; }
    else { text.innerText = "RECHALKING..."; text.style.color = "#aaa"; text.style.textShadow = "none"; }

    if (player.scratchUnlocked) document.getElementById('scratch-fill').style.width = `${clamp((1 - player.scratchCooldown / player.scratchMaxCooldown) * 100, 0, 100)}%`;
    if (player.spinUnlocked) document.getElementById('spin-fill').style.width = `${clamp((1 - player.spinCooldown / player.spinMaxCooldown) * 100, 0, 100)}%`;
    if (player.bankUnlocked) document.getElementById('bank-fill').style.width = `${clamp((1 - player.bankCooldown / player.bankMaxCooldown) * 100, 0, 100)}%`;
    if (player.nineBallUnlocked) document.getElementById('nineball-fill').style.width = `${clamp((1 - player.nineBallCooldown / player.nineBallMaxCooldown) * 100, 0, 100)}%`;
    if (player.chalkUnlocked) document.getElementById('chalk-fill').style.width = `${clamp((1 - player.chalkCooldown / player.chalkMaxCooldown) * 100, 0, 100)}%`;
    if (player.magic8Unlocked) document.getElementById('magic8-fill').style.width = `${clamp((1 - player.magic8Cooldown / player.magic8MaxCooldown) * 100, 0, 100)}%`;
}

function levelComplete() {
    game.upgradePending = true;
    setTimeout(() => { showUpgradeMenu(); }, 1000);
}

function showUpgradeMenu(isTutorial = false) {
    const overlay = document.getElementById('upgrade-overlay');
    const container = document.getElementById('cards-wrapper');
    const title = document.getElementById('upgrade-title');
    const sub = document.getElementById('upgrade-subtitle');
    const rerollBtn = document.getElementById('reroll-btn');
   
    overlay.style.display = 'flex';
    chaosChoicesMade = 0;

    function displayCardChoices(isTut, isChaos) {
        container.innerHTML = '';
        
        if (player.hasRerollAbility && !game.rerollSpentThisLevel && !isTut && !isChaos) {
            rerollBtn.style.display = 'block';
        } else {
            rerollBtn.style.display = 'none';
        }

        if (isChaos) {
            title.innerText = "CHAOS REWARD";
            sub.innerText = `CHOOSE ONE (${chaosChoicesMade + 1} / 3)`;
        } else {
            title.innerText = isTut ? "TUTORIAL UPGRADE" : "LEVEL CLEARED";
            sub.innerText = "CHOOSE AN UPGRADE";
        }

        let picks = [];
        while(picks.length < 3) {
            let r = pickWeightedCard();
            if (!picks.includes(r)) picks.push(r);
        }

        picks.forEach((opt, idx) => {
            let card = document.createElement('div');
            card.className = opt.rarity === 'rare' ? 'card rare' : (opt.rarity === 'golden' ? 'card golden' : 'card');
            card.innerHTML = `<h3>${opt.name}</h3><p>${opt.desc}</p>`;
            
            setTimeout(() => card.classList.add('drop-in'), idx * 100 + 50);

            card.onclick = () => {
                applyCard(opt, player);
                
                const allCards = container.querySelectorAll('.card');
                allCards.forEach(c => c.classList.add('slide-out'));

                setTimeout(() => {
                    if (isTut) {
                        overlay.style.display = 'none'; 
                        game.upgradePending = false; 
                        tutorial.step = 9; 
                        showTutorialStep(9);
                    } else if (isChaos) {
                        chaosChoicesMade++;
                        if (chaosChoicesMade < 3) {
                            displayCardChoices(false, true);
                        } else {
                            overlay.style.display = 'none'; 
                            game.upgradePending = false; 
                            game.level++; 
                            setupLevel();
                        }
                    } else {
                        overlay.style.display = 'none'; 
                        game.upgradePending = false; 
                        game.level++; 
                        setupLevel();
                    }
                }, 600); 
            };
            container.appendChild(card);
        });
    }

    displayCardChoices(isTutorial, game.mode === 'CHAOS');
}

function triggerReroll() {
    if (game.rerollSpentThisLevel) return;
    game.rerollSpentThisLevel = true;
    showUpgradeMenu();
}

function gameOver() {
    gameState = 'GAME_OVER'; game.active = false;
    let tokenBonus = game.mode === 'CHAOS' ? game.level * 1.5 : game.level;
    globalTokens += tokenBonus;
    if (game.level > globalBestRun) globalBestRun = game.level; saveData();
    document.getElementById('final-level').innerText = `${game.mode === 'CHAOS' ? 'CHAOS ' : ''}Level Reached: ${game.level}`;
    document.getElementById('earned-tokens').innerText = `Tokens Earned: ${tokenBonus.toFixed(1)}`;
    document.getElementById('game-over-screen').style.display = 'flex';
}

init();

</script>
</body>
</html>
